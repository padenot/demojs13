<meta charset="utf-8">
<style>
input[type=range] {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 99%;
  height: 30px;
}
body {
  padding: 0;
  margin: 0;
}
</style>
<body>
<canvas>
</canvas>
<input type=range id=seeker>
<script type="x-shader/fragment" id=green-red>
  precision lowp float;
  /* relative to scene start time */
  uniform float time;
  /* scene duration */
  uniform float duration;
  /* resolution */
  uniform vec2 res;

  float hash(float n)
  {
    return fract(sin(n)*43758.5453);
  }


  void main() {
    float speed = 20000.0;
    float x = gl_FragCoord.x;
    float y = gl_FragCoord.y;
    vec2 fc = vec2(gl_FragCoord.x, gl_FragCoord.y);
    float dist = length(fc - res);
    vec2 center = vec2(res.x / 2.0, res.y/2.0);
    float distcenter = abs(length(fc - center));
    float maxdist = length(res);
    float darken = 1.0;
    if (mod(y, 6.0) <= 2.0) {
      darken = 0.8;
    }
    darken = darken * (0.7 - distcenter / maxdist);
    gl_FragColor = vec4(hash(x / res.x + time / (duration*speed)) * darken,
                    0.5 * darken,
                    //    hash(y / res.y + time / (duration*speed)) * darken,
                        hash(dist / maxdist + time / (duration*speed)) * darken,
                        1.0);
  }
</script>
<script type="x-shader/fragment" id=bw>
  precision lowp float;
  /* relative to scene start time */
  uniform float time;
  /* scene duration */
  uniform float duration;
  /* resolution */
  uniform vec2 res;

  void main() {
    float col = (duration - time) / duration;
    gl_FragColor = vec4(cos(gl_FragCoord.x * col * 65366.0 * col),
                        sin(gl_FragCoord.y * col * 65366.0 * col),
                        tan(gl_FragCoord.x * col * 65366.0),
                        1.0);
  }
</script>
<script type="x-shader/vertex" id=quad>
  attribute vec2 position;

  void main() {
    gl_Position = vec4(position, 0.0, 1.0);
  }
</script>
<script>
  seeker = null;
  gl = null;
  cvs = null;
  /* vertex buffer for our quad */
  buffer = null;
  D = {
    /* time in ms */
    currentTime: 0,
    startTime: 0,
    endTime: 0,
    PAUSED: 0,
    PLAYING: 1,
    ENDED: 2,
    playState: null,
    scenes: [],
    programs: [],
    currentScene: null,
    currentProgram: null
  };
  function updateCurrentTime() {
    D.currentTime = Date.now() - D.startTime;
    seeker.value = D.currentTime;
    gl.uniform1f(gl.getUniformLocation(D.currentProgram, 'time'),
                 D.currentTime - D.scenes[D.currentScene].start);
    gl.uniform1f(gl.getUniformLocation(D.currentProgram, 'duration'),
                 D.scenes[D.currentScene].duration);
    gl.uniform2f(gl.getUniformLocation(D.currentProgram, 'res'),
                 cvs.width, cvs.height);
  }
  function seek(time) {
    D.startTime = Date.now() - time;
    D.currentTime = Date.now() - D.startTime;
    D.currentScene = findSceneForTime(D.currentTime);
    if (D.playState == D.PAUSED) {
      updateScene();
      render();
    }
    if (D.playState == D.ENDED) {
      D.playState = D.PLAYING;
      mainloop();
    }
  }
  function loadProgram(vertex, fragment) {
    var program = gl.createProgram();
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragment.textContent);
    gl.compileShader(fragmentShader);
    if ( !gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      alert("Shader compilation failed: " + gl.getShaderInfoLog(fragmentShader));
    }
    gl.shaderSource(vertexShader, vertex.textContent);
    gl.compileShader(vertexShader);
    if ( !gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      alert("Shader compilation failed: " + gl.getShaderInfoLog(vertexShader));
    }
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.deleteShader(vertexShader);
    gl.deleteShader(fragmentShader);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
       alert("Program link error: " +
             gl.getProgramParameter(program, gl.VALIDATE_STATUS) +
             "\nERROR: " + gl.getError());
    }
    return program;
  }
  function windowResize() {
    cvs.width = window.innerWidth;
    cvs.height = window.innerHeight;
    gl.viewport(0, 0, cvs.width, cvs.height);
  }
  function render() {
    if (!gl) {
      return;
    }
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.useProgram(D.currentProgram);
    updateCurrentTime();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(0);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.disableVertexAttribArray(0);
  }
  function findSceneForTime(time) {
     for(var i = 0; i < D.scenes.length; i++) {
       if (D.scenes[i].start <= time &&
           D.scenes[i].start + D.scenes[i].duration > time) {
         return i;
       }
     }
     throw "No scene found for time " + time;
  }
  function updateScene() {
    D.currentScene = findSceneForTime(D.currentTime);
    D.currentProgram = D.programs[D.currentScene];
  }
  function mainloop() {
    if (D.playState == D.PLAYING){
      if (D.currentTime <= D.endTime) {
        updateScene();
        requestAnimationFrame(mainloop);
        render();
        D.playState = D.PLAYING;
      } else {
        D.playState = D.ENDED;
      }
    }
  }

  function assertScenesSorted() {
    for (var i = 0; i < D.scenes - 1; i++) {
      if (!(D.scenes[i].startTime + D.scene[i].duration <= D.scenes[i+1].startTime)) {
        throw "Scenes not sorted in chronological order, aborting.";
      }
    }
  }
  window.addEventListener("resize", windowResize);

  document.addEventListener("DOMContentLoaded", function () {
    cvs = document.getElementsByTagName("canvas")[0];
    gl = cvs.getContext("experimental-webgl");
    buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    quad = new Float32Array([-1, -1,
                              1, -1,
                             -1,  1,
                              1, -1,
                              1,  1,
                             -1,  1]);
    gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);

    windowResize();

    seeker = document.getElementById("seeker");
    document.addEventListener("input", function (e) {
      seek(e.target.value);
      seeker.value = e.target.value;
    });

    document.addEventListener("keypress", function(e) {
      // play/pause
      if (e.charCode == 32) {
        if (D.playState == D.PLAYING) {
          D.pauseStart = Date.now();
          D.playState = D.PAUSED;
        } else if(D.playState == D.ENDED) {
          seek(0);
        } else {
          D.startTime += Date.now() - D.pauseStart;
          D.playState = D.PLAYING;
          mainloop();
        }
      }
      else {
  	    // jump to scene
  		  var s = e.charCode -48 - 1;
  		  if (s >= 0 && s <=9 && s < D.scenes.length) 
    	    seek(D.scenes[s].start);
      }
    });

    D.startTime = Date.now();
    D.currentTime = 0;
    D.playState = D.PLAYING;

    D.scenes = [
     { start: 0,
       duration: 5000,
       fragment: document.getElementById("green-red"),
       vertex: document.getElementById("quad") },
     { start: 5000,
       duration: 15000,
       fragment: document.getElementById("bw"),
       vertex: document.getElementById("quad") }
    ];

    assertScenesSorted();

    var lastScene = D.scenes[D.scenes.length - 1];
    seeker.max = D.endTime = lastScene.start + lastScene.duration;

    D.programs = [];
    for (var i = 0; i < D.scenes.length; i++) {
      D.programs.push(loadProgram(D.scenes[i].vertex, D.scenes[i].fragment));
    }

    D.currentProgram = D.programs[0];
    D.currentScene = 0;
    requestAnimationFrame(mainloop);
  });
</script>
</body>
